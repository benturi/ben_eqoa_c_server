#include <stdio.h>      
#include <string.h>
#include <stdlib.h>    
#include <sys/types.h>   
#include <errno.h>
//
struct Session_Request_Packet
{
    uint16_t ClientCode;
    uint16_t ServerCode;
    uint8_t  PacketLength;
    uint8_t  OpCode;
    uint8_t  OpOption;
    uint16_t ClientCode2;
    uint16_t SessionCode;
    uint8_t  MessageType;
    uint16_t ClientPacketNum;
    uint32_t CRC;
    uint32_t CRC_INIT;
};

//
uint32_t Process_Session_Request(unsigned char* buf,int msglen,unsigned char *response,unsigned int *resplen){
    
  struct Session_Request_Packet srp;
//
  unsigned char SessionResponseTemplate_S2C[] = {
  0xb0, 0x73, 0x5a, 0xe7, 0x95, 0x60, 0x5a, 0xe7, 
  0x05, 0x00, 0x63, 0x5a, 0xe7, 0x05, 0x00, 0x01, 
  0x00, 0x01, 0x00, 0x02, 0x00, 0xfb, 0x06, 0x01, 
  0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x7c, 
  0x69, 0xb6, 0x9e };
//
// Read updated values from the payload from the client
//
  memcpy(&srp.ClientCode, buf, 2);
  memcpy(&srp.ServerCode, buf+2, 2);
  memcpy(&srp.PacketLength, buf+4, 1);
  memcpy(&srp.OpCode, buf+5, 1);
  memcpy(&srp.OpOption, buf+6, 1);
  memcpy(&srp.ClientCode2, buf+7, 2);
  memcpy(&srp.SessionCode, buf+9, 2);
  memcpy(&srp.MessageType, buf+11, 1);
  memcpy(&srp.ClientPacketNum, buf+12, 2);
  memcpy(&srp.CRC, buf+msglen-4, 4);  
//  
// Copy Template into Response    
//    
  memcpy(response,&SessionResponseTemplate_S2C, sizeof(SessionResponseTemplate_S2C));
//
// Replace specific bytes
//
// Replace ServerCode in one place
//
     if(srp.ClientCode!=srp.ClientCode2)
     {
     memcpy(response,&srp.ServerCode,2);
     }
     //   
// Replaces the ClientCode in one place
//    
    memcpy(response+2,&srp.ClientCode, 2);
//
//  Replace ClientCode2 in two places
//    
    memcpy(response+6,&srp.ClientCode2, 2);    
    memcpy(response+11,&srp.ClientCode2, 2);  
//
// Replace the SessionCode in two places
//
    memcpy(response+8, &srp.SessionCode, 2);
    memcpy(response+13,&srp.SessionCode, 2); 
//    
// Save CRC init in here
//
    srp.CRC_INIT=0x48e05191;
//
    *resplen = sizeof(SessionResponseTemplate_S2C);

//
return srp.CRC_INIT;
}
//
/////////////////////////////////////////////////////////
//
uint32_t Process_Server_Complex_Request(unsigned char* buf,int msglen,unsigned char *response,unsigned int *resplen)
{
  struct Session_Request_Packet scr;
//
unsigned char MainServerListResponseTemplate_S2C[] =
 {
    0xb0, 0x73, 0x5a, 0xe7, 0x9c, 0x62, 0x5a, 0xe7, 
    0x05, 0x00, 0x20, 0x02, 0x00, 0xfc, 0xff, 0x15, 
    0x01, 0xb3, 0x07, 0x0e, 0x10, 0x00, 0x00, 0x00, 
    0x43, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 
    0x6c, 0x00, 0x65, 0x00, 0x20, 0x00, 0x4c, 0x00, 
    0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 
    0x77, 0x00, 0x6f, 0x00, 0x6c, 0x00, 0x66, 0x00, 
    0x00, 0x0a, 0x1f, 0x57, 0x27, 0x30, 0x0a, 0x6c, 
    0xc7, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x44, 0x00, 
    0x69, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6e, 0x00, 
    0x20, 0x00, 0x48, 0x00, 0x6f, 0x00, 0x6c, 0x00, 
    0x64, 0x00, 0x00, 0x01, 0x3e, 0x56, 0x27, 0x48, 
    0x0a, 0x6c, 0xc7, 0x00, 0x0d, 0x00, 0x00, 0x00, 
    0x46, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 
    0x61, 0x00, 0x6e, 0x00, 0x27, 0x00, 0x73, 0x00, 
    0x20, 0x00, 0x48, 0x00, 0x6f, 0x00, 0x70, 0x00, 
    0x65, 0x00, 0x00, 0x1c, 0x24, 0x56, 0x27, 0x74, 
    0x0a, 0x6c, 0xc7, 0x00, 0x08, 0x00, 0x00, 0x00, 
    0x48, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x73, 0x00, 
    0x74, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x6b, 0x00, 
    0x00, 0x91, 0xb9, 0x56, 0x27, 0x84, 0x0a, 0x6c, 
    0xc7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x4d, 0x00, 
    0x61, 0x00, 0x72, 0x00, 0x72, 0x00, 0x27, 0x00, 
    0x73, 0x00, 0x20, 0x00, 0x46, 0x00, 0x69, 0x00, 
    0x73, 0x00, 0x74, 0x00, 0x00, 0x9e, 0xbd, 0x57, 
    0x27, 0x25, 0xc8, 0x6c, 0xc7, 0x00, 0x11, 0x00, 
    0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 
    0x75, 0x00, 0x64, 0x00, 0x70, 0x00, 0x69, 0x00, 
    0x6e, 0x00, 0x65, 0x00, 0x20, 0x00, 0x4f, 0x00, 
    0x75, 0x00, 0x74, 0x00, 0x70, 0x00, 0x6f, 0x00, 
    0x73, 0x00, 0x74, 0x00, 0x00, 0xa9, 0xd7, 0x56, 
    0x27, 0x44, 0xc8, 0x6c, 0xc7, 0x00, 0x0d, 0x00, 
    0x00, 0x00, 0x48, 0x00, 0x61, 0x00, 0x67, 0x00, 
    0x6c, 0x00, 0x65, 0x00, 0x79, 0x00, 0x20, 0x00, 
    0x28, 0x00, 0x54, 0x00, 0x65, 0x00, 0x73, 0x00, 
    0x74, 0x00, 0x29, 0x00, 0x01, 0x35, 0x9b, 0x56, 
    0x27, 0xeb, 0x0a, 0x6c, 0xc7, 0x00, 0x00, 0x00,
    0x00, 0x00    
    };
//
//
//    
 unsigned char WorldServerListResponseTemplate_S2C[] = {
0x0a, 0x1f, 0x5a, 0xe7, 0x97, 0xc0, 0x21, 0xf1, 
0x46, 0x32, 0x13, 0xd8, 0xbc, 0x0d, 0x20, 0x01, 
0x00, 0xfb, 0x06, 0x01, 0x00, 0xd1, 0x07, 0x03, 
0x00, 0x00, 0x00, 0xfb, 0x06, 0x02, 0x00, 0xf5, 
0x07, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00 };   
    
//     
// Benturi Server Mods
//    
 unsigned char BenturiServer[] =
 {
    0x42, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00,
    0x75, 0x00, 0x72, 0x00, 0x69, 0x00, 0x20, 0x00 
 };
 unsigned char BenturiServerIP[]   = {0x70, 0x01, 0xa8, 0xc0}; // 192.168.1.112 (little endien)
 unsigned char BenturiServerCode[] = {0x91, 0xb9}; // default CLW (7946)47505
 unsigned char BenturiServerPort[] = {0x56, 0x27}; // 10070 (little endien)
//
// This copies Benturi server name, Code, Port, and IP
//
 memcpy(MainServerListResponseTemplate_S2C+144,BenturiServer,sizeof BenturiServer);
 memcpy(MainServerListResponseTemplate_S2C+161,BenturiServerCode, sizeof BenturiServerCode); 
 memcpy(MainServerListResponseTemplate_S2C+163,BenturiServerPort, sizeof BenturiServerPort); 
 memcpy(MainServerListResponseTemplate_S2C+165,BenturiServerIP, sizeof BenturiServerIP);     
//
//
// Read updated values from the payload from the client
//
  memcpy(&scr.ClientCode, buf, 2);
  memcpy(&scr.ServerCode, buf+2, 2);
  memcpy(&scr.PacketLength, buf+4, 1);
  memcpy(&scr.OpCode, buf+5, 1);
  memcpy(&scr.OpOption, buf+6, 1);
  memcpy(&scr.ClientCode2, buf+7, 2);
  memcpy(&scr.SessionCode, buf+9, 2);
  memcpy(&scr.MessageType, buf+11, 1);
  memcpy(&scr.ClientPacketNum, buf+12, 2);
  memcpy(&scr.CRC, buf+msglen-4, 4);  
//
// This gets called twice. The first for the Server list and second for the character select screen
//

  if(scr.ClientCode==scr.ClientCode2)
  {
//
// Copy Template into Response    
//  
  memcpy(response,&MainServerListResponseTemplate_S2C, sizeof(MainServerListResponseTemplate_S2C));
//
// Replace specific bytes
//
// Replaces the ClientCode in one place
//    
    memcpy(response+2,&scr.ClientCode, 2);
//
// ClientCode2 in one place
//    
    memcpy(response+6,&scr.ClientCode2, 2);    
//
// Replace the SessionCode in one places
//
    memcpy(response+8, &scr.SessionCode, 2);
//    
    printf(" *** Processed Server Complex Response Packet ***\n");  
//
        *resplen = sizeof(MainServerListResponseTemplate_S2C);
        scr.CRC_INIT=0xb67d65cc;

//
  }
  else  // this is second time
  {      
   memcpy(response,&WorldServerListResponseTemplate_S2C, sizeof(WorldServerListResponseTemplate_S2C));
//
// Replace ServerCode in one place
//
   memcpy(response,&scr.ServerCode,2);
//
// Replaces the ClientCode in one place
//    
    memcpy(response+2,&scr.ClientCode, 2);
//
    printf(" *** Processed World Server Complex Response Packet ***\n");  
//
        *resplen = sizeof(WorldServerListResponseTemplate_S2C);
        scr.CRC_INIT=0xfa799a21 ;

//
  }    
//   
//
return scr.CRC_INIT;
}
//
//////////////////////////////////////////////////
//

uint32_t Process_Character_Request(unsigned char* buf,int msglen,unsigned char *response,unsigned int *resplen){
    
  struct Character_Request_Packet
{
    uint16_t ClientCode;
    uint16_t ServerCode;
    uint8_t  PacketLength;
    uint8_t  OpCode;
    uint8_t  OpOption;
    uint16_t ClientCode2;
    uint16_t SessionCode;
    uint8_t  MessageType;
    uint16_t ClientPacketNum;
    uint32_t CRC;
    uint32_t CRC_INIT;
};  
   
  struct Character_Request_Packet crp;
//
unsigned char WorldServercharacterListResponseTemplate_S2C[] = {
0x0a, 0x1f, // client code
0x5a, 0xe7, // server code
0xa0,       // related to packet length
0xc6, 0x01, 0xf1, 
0x46, 0x32, 0x13, 0xd8, 0xbc, 0x0d, 0x20, 0x02, 
0x00, 0xfb, 0xff, 0x17, 0x03, 0x03, 0x00, 0x2c, 
0x00,
//
0x10,       // number of characters in 0x10 = 16/2 = 8 characters
//
// Ferry
//
0x05, 0x00, 0x00, 0x00,       // Length of Name
0x46, 0x65, 0x72, 0x72, 0x79, // Character Name
0x90, 0xa0, 0x8b, 0x01,       // 
0xbe, 0xfb, 0xd1, 0x9c,       // Model of Class - actually draws it
0x0c, //  
0x10,                         // Class - Just to write name in character window
0x00, //0x0c,                 // Race  - determines music and background (not actual image)
0x78, //0x78,  64             // Level ( if lvl 60 it changes background) - [level*2]
0x00,                         // Hair Color
0x00,                         // Hair Length
0x04,                         // Hair Style
0x06,                         // Face
0x00, 0x00, 0x00, 0x00,       // ??
0x85, 0x6c, 0x40, 0xd8,       // Primary
0xcb, 0x7d, 0x7e, 0xbf,       // Secondary
0x00, 0x00, 0x00, 0x00,       // Shield
0x03, 0x00,                   // Animation
0x00,                         // ??
0x00,// 0x03,                         // Chest 
0x00,//0x00,                         // Bracer
0x00,//0x03,                         // Gloves
0x00,//0x03,                         // Pants
0x00,//0x03,                         // Boot
0x00,//0x07,                         // Helm
0x00, 0x00,                   // ??
0x00, 0x00, 0x00, 0x00,
// Colors - first 3 bytes in each row are RGB values 
//
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, // Chest Color
0xff, 0xff, 0xff, 0xff, // Bracer Color
0xff, 0xff, 0xff, 0xff, // Glove Color
0xff, 0xff, 0xff, 0xff, // Pant Color
0x00, 0x80, 0x00, 0xff, // Boot Color
0xf0, 0xf0, 0x00, 0xff, // Helm Color
0x00, 0x80, 0x00, 0xff, // Robe Color 
//
// Daydrift
//
0x08, 0x00, 0x00, 0x00, 0x44, 0x61, 
0x79, 0x64, 0x72, 0x69, 0x66, 0x74, 0xc6, 0xbb, 
0x8b, 0x01, 0x8f, 0xc0, 0xd4, 0xf2, 0x04, 0x18, 
0x02, 0x78, 0x00, 0x04, 0x02, 0x02, 0x00, 0x00, 
0x00, 0x00, 0xa9, 0xbe, 0x7d, 0x7c, 0x00, 0x00, 
0x00, 0x00, 0x29, 0x60, 0xc5, 0x2e, 0x03, 0x00, 
0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 
0x00, 0x02, 0x03, 0x00, 0x00, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x39, 0x64, 
0xff, 0x80, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x3f, 0x76, 0x94, 0xff, 0x80, 0x00, 0x80, 
0xff, 0x75, 0x00, 0x75, 0xff, 0x44, 0x44, 0x88, 
0xff, 0xff, 0x00, 0x00, 0xff, 0x04, 0x00, 0x00, 
0x00, 0x4c, 0x65, 0x61, 0x72, 0xfa, 0xd5, 0x8b, 
0x01, 0x8f, 0xc0, 0xd4, 0xf2, 0x04, 0x0e, 0x02, 
0x78, 0x02, 0x06, 0x02, 0x02, 0x00, 0x00, 0x00, 
0x00, 0x85, 0x6c, 0x40, 0xd8, 0x00, 0x00, 0x00, 
0x00, 0x73, 0xe8, 0xa6, 0x0a, 0x03, 0x00, 0x00, 
0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 
0x03, 0x03, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x50, 0x64, 0x00, 0xff, 
0x00, 0x40, 0x40, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x00, 0x40, 0x40, 0xff, 0x00, 0x40, 0x40, 0xff, 
0x00, 0x40, 0x40, 0xff, 0x50, 0x64, 0x00, 0xff, 
0x00, 0x80, 0x00, 0xff, 0x07, 0x00, 0x00, 0x00, 
0x42, 0x65, 0x6e, 0x74, 0x75, 0x72, 0x69, 0xc4, 
0x89, 0x8d, 0x01, 0x8f, 0xc0, 0xd4, 0xf2, 0x04, 
0x12, 0x02, 0x78, 0x00, 0x06, 0x06, 0x02, 0x00, 
0x00, 0x00, 0x00, 0x85, 0x6c, 0x40, 0xd8, 0xa8, 
0xe4, 0x2c, 0x99, 0x00, 0x00, 0x00, 0x00, 0x03, 
0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 0x04, 
0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x1b, 0xed, 0x59, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x79, 0x79, 0xbd, 0xff, 0x2d, 0x84, 
0x3c, 0xff, 0x79, 0x79, 0xbd, 0xff, 0x9e, 0x9c, 
0x38, 0xff, 0x00, 0x80, 0x00, 0xff, 0x0b, 0x00, 
0x00, 0x00, 0x48, 0x79, 0x6d, 0x6e, 0x6f, 0x66, 
0x70, 0x6f, 0x77, 0x65, 0x72, 0xf2, 0x81, 0x93, 
0x01, 0x8f, 0xc0, 0xd4, 0xf2, 0x04, 0x0a, 0x02, 
0x78, 0x00, 0x06, 0x04, 0x02, 0x01, 0x00, 0x00, 
0x00, 0x0b, 0x87, 0xf9, 0x17, 0x1a, 0x99, 0xdd, 
0xf4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x00, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 
0x02, 0x03, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x80, 0xff, 0xd6, 0xff, 0x00, 0x9f, 0x9f, 0xff, 
0x00, 0x41, 0x82, 0xff, 0x00, 0x9f, 0x9f, 0xff, 
0x00, 0x80, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x15, 0x00, 0x00, 0xff, 0x06, 0x00, 0x00, 0x00, 
0x4e, 0x65, 0x63, 0x6e, 0x6f, 0x6b, 0xac, 0xc3, 
0x94, 0x01, 0xd5, 0xd3, 0x9c, 0xe6, 0x0a, 0x16, 
0x06, 0x78, 0x06, 0x06, 0x02, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xa9, 0xbe, 0x7d, 0x7c, 0x7c, 0x8b, 
0x08, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x96, 0x00, 0x3c, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x96, 0x00, 0x3c, 0xff, 0x96, 0x00, 0x3c, 
0xff, 0x31, 0x62, 0x62, 0xff, 0x15, 0x00, 0x00, 
0xff, 0xff, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 
0x00, 0x44, 0x75, 0x64, 0x64, 0x65, 0x72, 0x7a, 
0xf6, 0xc3, 0x95, 0x01, 0xe4, 0x94, 0xfd, 0xc6, 
0x09, 0x00, 0x0a, 0x78, 0x00, 0x06, 0x00, 0x04, 
0x00, 0x00, 0x00, 0x00, 0x4d, 0x22, 0xb7, 0x6e, 
0x0b, 0x87, 0xf9, 0x17, 0x00, 0x00, 0x00, 0x00, 
0x01, 0x01, 0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 
0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x62, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x40, 0x00, 0x80, 0xff, 0xa0, 
0xaa, 0xb4, 0xff, 0x40, 0x00, 0x80, 0xff, 0x40, 
0x00, 0x80, 0xff, 0x00, 0x00, 0xff, 0xff, 0x0c, 
0x00, 0x00, 0x00, 0x43, 0x6f, 0x72, 0x73, 0x74, 
0x65, 0x6e, 0x73, 0x62, 0x61, 0x6e, 0x6b, 0xba, 
0xef, 0x99, 0x01, 0x8c, 0xe3, 0xc4, 0x8d, 0x0e, 
0x14, 0x00, 0x02, 0x02, 0x04, 0x04, 0x04, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
0x00, 0x00 };
//
// Read updated values from the payload from the client
//
  memcpy(&crp.ClientCode, buf, 2);
  memcpy(&crp.ServerCode, buf+2, 2);
  memcpy(&crp.PacketLength, buf+4, 1);
  memcpy(&crp.OpCode, buf+5, 1);
  memcpy(&crp.CRC, buf+msglen-4, 4);  
//  
// Copy Template into Response    
//    
  memcpy(response,&WorldServercharacterListResponseTemplate_S2C, sizeof(WorldServercharacterListResponseTemplate_S2C));
//
// Replace specific bytes
//
// Replace ServerCode in one place
//
     memcpy(response,&crp.ServerCode,2);
//   
// Replaces the ClientCode in one place
//    
    memcpy(response+2,&crp.ClientCode, 2);
//  
// Save CRC init in here
//
    crp.CRC_INIT=0x40459ca6;
//
    *resplen = sizeof(WorldServercharacterListResponseTemplate_S2C);

//
return crp.CRC_INIT;
}
//
//////////////////////////////////////////////////
//

uint32_t Process_Dummy(unsigned char* buf,int msglen,unsigned char *response,unsigned int *resplen){
   
//
  unsigned char SessionResponseTemplate_S2C[] = {
  0xb0, 0x73, 0x5a, 0xe7, 0x95, 0x60, 0x5a, 0xe7, 
  0x05, 0x00, 0x63, 0x5a, 0xe7, 0x05, 0x00, 0x01, 
  0x00, 0x01, 0x00, 0x02, 0x00, 0xfb, 0x06, 0x01, 
  0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x7c, 
  0x69, 0xb6, 0x9e };
//  
// Copy Template into Response    - this one just used to check CRC implimentation
//    
  memcpy(response,&SessionResponseTemplate_S2C, sizeof(SessionResponseTemplate_S2C));
// 
    *resplen = sizeof(SessionResponseTemplate_S2C);

//
return 0x48e05191;
}


